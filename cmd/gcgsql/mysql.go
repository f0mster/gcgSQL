package main

var templatesMysql = `
// Code generated by gcgSQL. DO NOT EDIT.
package {{.Pkg}}

import (
{{- if .WithContext }}
	"context"
{{end}}
	"database/sql"
	"fmt"
	{{$HaveRepeatableParts := false}}
{{range $k, $v :=.QueriesData -}}
	{{- if $v.HaveRepeatableParts -}}
		{{$HaveRepeatableParts = true}}
	{{- end -}}
{{- end -}}
{{- if $HaveRepeatableParts}}
	"strings"
{{end -}}
    {{- range $k, $v := .Imports}}
	{{$v}}
{{- end -}}
)

type {{.ConnectorName}}connect interface {
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
}

{{$havectx:=.WithContext}}{{$Ctx := ""}}{{- if .WithContext}}{{$Ctx = "ctx context.Context, "}}{{end}}
{{- define "queryAndArgs"}}{{if .HaveRepeatableParts}}query, args ...{{else}}"{{.ReplacePlaceHoldersInQueryIfNoRepeatable '?'| Escape}}"{{.Arguments.PrintNamesAndTypes "," "" false}}{{end}}{{end}}
{{- define "returnIfError"}}if err != nil {
		return nil, fmt.Errorf("error while executing function {{.Name}} %w", err)
	}{{end}}
{{- define "haveRepeatableArgs"}}{{$linestart:=""}}{{if .HaveRepeatableParts}}
	var subString strings.Builder
	var first = true
	query := "{{.Query| Escape}}"
	cnt := {{.Arguments.CountArgs}}
	var args = make([]interface{}, cnt)
	i:=0
	{{range $k, $v := .Arguments -}}
		{{if $v.Repeatable -}}
			{{$subQuery := $v.RepeatedQuery}}
			{{- range $k2, $v2 := $v.RepeatedArgs -}}
				{{$subQuery = (Replace $subQuery $v2.PlaceHolder "?" -1)}}
			{{- end}}
	first = true
	subString.Reset()
	for _, v:= range {{$v.ArgName}} {
			{{- if ne $v.RepeatedQuery "" -}}
				{{range $k2, $v2 := $v.RepeatedArgs -}}
					{{$subQuery = (Replace $subQuery $v2.PlaceHolder "?" -1)}}
		args[i+{{$k2}}] = v.{{$v2.ArgName -}}
				{{end}}
		i+={{len $v.RepeatedArgs}}
			{{else}}
		args[i] = v
		i++
			{{- end -}}
			{{if ne $v.Separator "" -}}
{{$linestart}}
		if first {
			first = false
		} else {
			subString.Write([]byte("{{$v.Separator| Escape}}"))
		}
			{{- end -}}
{{$linestart:=""}}
		subString.Write([]byte("{{if eq $subQuery ""}}?{{else}}{{$subQuery| Escape}}{{end}}"))
	}
	query = strings.Replace(query, "{{$v.PlaceHolder|Escape}}", subString.String(), -1)
		{{- else -}}
{{$linestart}}
	query = strings.Replace(query, "{{$v.PlaceHolder|Escape}}", "?", -1)
	args[i] = $v.ArgName
	i++
		{{end -}}
	{{end -}}
	{{end -}}	
{{end -}}

{{$isStructAlreadySet := MakeMapStringBool}}

{{range $k, $v :=.QueriesData}}
{{if $v.HaveRepeatableParts}}
	{{range $k2, $v2 := $v.Arguments}}
		{{if and ($v2.IsGeneratedName) (not (index $isStructAlreadySet $v2.ArgName))}}
			{{$tmp := SetMapStringBoolValue $isStructAlreadySet $v2.ArgName true}}
			type {{$v2.ArgType}} struct {
			{{$v2.RepeatedArgs.PrintNamesAndTypes "	" "\n" true}}
			}
		{{end}}
	{{end}}
{{end}}
{{if gt (len $v.ReturnParams) 0}}
{{if eq .ReturnParamsType ""}}
type {{$v.Name}}Struct struct {
{{$v.ReturnParams.PrintNamesAndTypes "	" "\n" true}}
}
{{end}}

func {{.Name}}({{$Ctx}}conn {{.ConnectorName}}connect{{.Arguments.PrintNamesAndTypes ", " "" true}}) ([]{{if eq .ReturnParamsType ""}}{{.Name}}Struct{{else}}{{.ReturnParamsType}}{{end}}, error) {
	{{template "haveRepeatableArgs" .}}
	res, err := conn.QueryContext({{if $havectx}}ctx{{else}}nil{{end}},{{template "queryAndArgs" .}})
	{{template "returnIfError" .}}
	ret{{.Name|Title}}Struct := make([]{{if eq .ReturnParamsType ""}}{{.Name}}Struct{{else}}{{.ReturnParamsType}}{{end}}, 0)
	for res.Next() {
		retStructRow := {{if eq .ReturnParamsType ""}}{{.Name}}Struct{{else}}{{.ReturnParamsType}}{{end}}{}
		err = res.Scan({{.ReturnParams.PrintNamesAndTypes "&retStructRow." "," false}})
		{{template "returnIfError" .}}
		ret{{.Name|Title}}Struct = append(ret{{.Name|Title}}Struct, retStructRow)
	}
	res.Close()
	return ret{{.Name|Title}}Struct, nil
}
{{else}}
func {{.Name}}({{$Ctx}}conn {{.ConnectorName}}connect{{.Arguments.PrintNamesAndTypes ", " "" true}}) (sql.Result, error) {
	{{template "haveRepeatableArgs" .}}	
	res, err := conn.ExecContext({{if $havectx}}ctx{{else}}nil{{end}}, {{template "queryAndArgs" .}})
	{{template "returnIfError" .}}
	return res, nil
}
{{end}}{{end}}
`
