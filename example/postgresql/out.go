// Code generated by gcgSQL. DO NOT EDIT.
package main

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"strconv"
)

func addUser(ctx context.Context, conn *sql.Tx, name string) (sql.Result, error) {

	res, err := conn.ExecContext(ctx, "insert into users set name=$1", name)
	if err != nil {
		return nil, fmt.Errorf("error while executing function addUser %w", err)
	}
	return res, nil
}

type userdataStruct struct {
	id   int
	name string
}

func addbulkusers(ctx context.Context, conn *sql.Tx, userdata []userdataStruct) (sql.Result, error) {

	var subString strings.Builder
	var first = true
	query := "insert into users (id, name) values $0$"
	cnt := len(userdata) * 2
	var args = make([]interface{}, cnt)
	i := 0
	subQuery := ""

	first = true
	subString.Reset()
	for _, v := range userdata {
		subQuery = "($0$, $1$)"

		args[i] = v.id
		i++
		subQuery = strings.Replace(subQuery, "$0$", "$"+strconv.Itoa(i), -1)

		args[i] = v.name
		i++
		subQuery = strings.Replace(subQuery, "$1$", "$"+strconv.Itoa(i), -1)

		if first {
			first = false
		} else {
			subString.Write([]byte(","))
		}

		subString.Write([]byte(subQuery))
	}
	query = strings.Replace(query, "$0$", subString.String(), -1)

	res, err := conn.ExecContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error while executing function addbulkusers %w", err)
	}
	return res, nil
}

func addbulkusers2(ctx context.Context, conn *sql.Tx, userdata []sometype) (sql.Result, error) {

	var subString strings.Builder
	var first = true
	query := "insert into users (id, name) values $0$"
	cnt := len(userdata) * 2
	var args = make([]interface{}, cnt)
	i := 0
	subQuery := ""

	first = true
	subString.Reset()
	for _, v := range userdata {
		subQuery = "($0$, $1$)"

		args[i] = v.id
		i++
		subQuery = strings.Replace(subQuery, "$0$", "$"+strconv.Itoa(i), -1)

		args[i] = v.name
		i++
		subQuery = strings.Replace(subQuery, "$1$", "$"+strconv.Itoa(i), -1)

		if first {
			first = false
		} else {
			subString.Write([]byte(","))
		}

		subString.Write([]byte(subQuery))
	}
	query = strings.Replace(query, "$0$", subString.String(), -1)

	res, err := conn.ExecContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error while executing function addbulkusers2 %w", err)
	}
	return res, nil
}

type findUsersIdInStruct struct {
	id    int
	name  string
	info  string
	login string
}

func findUsersIdIn(ctx context.Context, conn *sql.Tx, userId []int) ([]*findUsersIdInStruct, error) {

	var subString strings.Builder
	var first = true
	query := "select id, name, info, login from users where id in ($0$)"
	cnt := len(userId) * 1
	var args = make([]interface{}, cnt)
	i := 0
	subQuery := ""

	first = true
	subString.Reset()
	for _, v := range userId {
		subQuery = ""

		args[i] = v
		i++

		if first {
			first = false
		} else {
			subString.Write([]byte(","))
		}

		subString.Write([]byte("$" + strconv.Itoa(i) + subQuery))
	}
	query = strings.Replace(query, "$0$", subString.String(), -1)

	res, err := conn.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error while executing function findUsersIdIn %w", err)
	}
	retFindUsersIdInStruct := make([]*findUsersIdInStruct, 0)
	for res.Next() {
		retStructRow := findUsersIdInStruct{}
		err = res.Scan(&retStructRow.id, &retStructRow.name, &retStructRow.info, &retStructRow.login)
		if err != nil {
			return nil, fmt.Errorf("error while executing function findUsersIdIn %w", err)
		}
		retFindUsersIdInStruct = append(retFindUsersIdInStruct, &retStructRow)
	}
	res.Close()
	return retFindUsersIdInStruct, nil
}

type lnStruct struct {
	login string
	name  string
}

type findUsersIdInOrByLoginAndNameStruct struct {
	id    int
	name  string
	info  sql.NullString
	login sql.NullString
}

func findUsersIdInOrByLoginAndName(ctx context.Context, conn *sql.Tx, userId []int, ln []lnStruct) ([]*findUsersIdInOrByLoginAndNameStruct, error) {

	var subString strings.Builder
	var first = true
	query := "select id, name, info, login from test.users where id in ($0$) $1$  or admin=1"
	cnt := len(userId)*1 + len(ln)*2
	var args = make([]interface{}, cnt)
	i := 0
	subQuery := ""

	first = true
	subString.Reset()
	for _, v := range userId {
		subQuery = ""

		args[i] = v
		i++

		if first {
			first = false
		} else {
			subString.Write([]byte(","))
		}

		subString.Write([]byte("$" + strconv.Itoa(i) + subQuery))
	}
	query = strings.Replace(query, "$0$", subString.String(), -1)

	first = true
	subString.Reset()
	for _, v := range ln {
		subQuery = " or (login=$0$ and name=$1$)"

		args[i] = v.login
		i++
		subQuery = strings.Replace(subQuery, "$0$", "$"+strconv.Itoa(i), -1)

		args[i] = v.name
		i++
		subQuery = strings.Replace(subQuery, "$1$", "$"+strconv.Itoa(i), -1)

		subString.Write([]byte(subQuery))
	}
	query = strings.Replace(query, "$1$", subString.String(), -1)

	res, err := conn.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error while executing function findUsersIdInOrByLoginAndName %w", err)
	}
	retFindUsersIdInOrByLoginAndNameStruct := make([]*findUsersIdInOrByLoginAndNameStruct, 0)
	for res.Next() {
		retStructRow := findUsersIdInOrByLoginAndNameStruct{}
		err = res.Scan(&retStructRow.id, &retStructRow.name, &retStructRow.info, &retStructRow.login)
		if err != nil {
			return nil, fmt.Errorf("error while executing function findUsersIdInOrByLoginAndName %w", err)
		}
		retFindUsersIdInOrByLoginAndNameStruct = append(retFindUsersIdInOrByLoginAndNameStruct, &retStructRow)
	}
	res.Close()
	return retFindUsersIdInOrByLoginAndNameStruct, nil
}

type findUsersWithStruct struct {
	id    int
	name  string
	info  string
	login string
}

func findUsersWith(ctx context.Context, conn *sql.Tx, userId int) ([]*findUsersWithStruct, error) {

	res, err := conn.QueryContext(ctx, "select id, name, info, login from users where id=$1", userId)
	if err != nil {
		return nil, fmt.Errorf("error while executing function findUsersWith %w", err)
	}
	retFindUsersWithStruct := make([]*findUsersWithStruct, 0)
	for res.Next() {
		retStructRow := findUsersWithStruct{}
		err = res.Scan(&retStructRow.id, &retStructRow.name, &retStructRow.info, &retStructRow.login)
		if err != nil {
			return nil, fmt.Errorf("error while executing function findUsersWith %w", err)
		}
		retFindUsersWithStruct = append(retFindUsersWithStruct, &retStructRow)
	}
	res.Close()
	return retFindUsersWithStruct, nil
}

type getAllUsersStruct struct {
	id   int
	name sql.NullString
}

func getAllUsers(ctx context.Context, conn *sql.Tx) ([]*getAllUsersStruct, error) {

	res, err := conn.QueryContext(ctx, "select id, name from \"test\".\"users\"")
	if err != nil {
		return nil, fmt.Errorf("error while executing function getAllUsers %w", err)
	}
	retGetAllUsersStruct := make([]*getAllUsersStruct, 0)
	for res.Next() {
		retStructRow := getAllUsersStruct{}
		err = res.Scan(&retStructRow.id, &retStructRow.name)
		if err != nil {
			return nil, fmt.Errorf("error while executing function getAllUsers %w", err)
		}
		retGetAllUsersStruct = append(retGetAllUsersStruct, &retStructRow)
	}
	res.Close()
	return retGetAllUsersStruct, nil
}

type getUserByNameStruct struct {
	name string
	id   int
}

func getUserByName(ctx context.Context, conn *sql.Tx, name string, altername string) ([]*getUserByNameStruct, error) {

	res, err := conn.QueryContext(ctx, "select name, id from users where name like $1 or name like $2", name, altername)
	if err != nil {
		return nil, fmt.Errorf("error while executing function getUserByName %w", err)
	}
	retGetUserByNameStruct := make([]*getUserByNameStruct, 0)
	for res.Next() {
		retStructRow := getUserByNameStruct{}
		err = res.Scan(&retStructRow.name, &retStructRow.id)
		if err != nil {
			return nil, fmt.Errorf("error while executing function getUserByName %w", err)
		}
		retGetUserByNameStruct = append(retGetUserByNameStruct, &retStructRow)
	}
	res.Close()
	return retGetUserByNameStruct, nil
}

func updateUserName(ctx context.Context, conn *sql.Tx, name string, userId int) (sql.Result, error) {

	res, err := conn.ExecContext(ctx, "update users set name=$1 where id=$2", name, userId)
	if err != nil {
		return nil, fmt.Errorf("error while executing function updateUserName %w", err)
	}
	return res, nil
}
