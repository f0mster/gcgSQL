package main

var mysqlAllowedType = map[string]interface{}{
	"uint8":           0,
	"uint16":          0,
	"uint32":          0,
	"uint64":          0,
	"int8":            0,
	"int16":           0,
	"int32":           0,
	"int64":           0,
	"float32":         0,
	"float64":         0,
	"int":             0,
	"uint":            0,
	"byte":            0,
	"rune":            0,
	"sql.NullInt32":   0,
	"sql.NullInt64":   0,
	"sql.NullFloat64": 0,
	"[]byte":          "",
	"string":          "",
	"sql.NullBool":    false,
	"sql.NullString":  "",
	"sql.NullTime":    0,
}

var templatesMysql = `// Code generated by gcgSQL. DO NOT EDIT. 
package {{.Package}}

import (	
	"database/sql"
)
{{range $k, $v :=.Queries}}{{if gt (len $v.ReturnParams) 0}}
type {{$k}}Struct struct {
{{range $k1, $v1 := $v.ReturnParams}}	{{$v1.ArgName}} {{$v1.ArgType}}
{{end}}
}{{end}}

{{if gt (len .ReturnParams) 0}} 
func {{$k}}(tx *sql.Tx{{range $k2, $v2 := $v.Arguments}}, {{$v2.ArgName}} {{$v2.ArgType}}{{end}}) ([]*{{$k}}Struct, error) {
	res, err := tx.Query("{{$v.Query| Escape}}"{{PrintCallParams $v.Arguments "" true}})
	if err != nil {
		return nil, err
	}
	ret{{$k}}Struct := make([]*{{$k}}Struct, 0)
	for res.Next() {
		retStructRow := {{$k}}Struct{}
		err = res.Scan({{PrintCallParams $v.ReturnParams "&retStructRow." false}})
		if err != nil {
			return nil, err
		}
		ret{{$k}}Struct = append(ret{{$k}}Struct, &retStructRow)
	}
	res.Close()
	return ret{{$k}}Struct, nil
}
{{else}}
func {{$k}}(tx *sql.Tx{{range $k2, $v2 := $v.Arguments}}, {{$v2.ArgName}} {{$v2.ArgType}}{{end}}) (sql.Result, error) {
	return tx.Exec("{{$v.Query| Escape}}")
}
{{end}}


{{end}}
`
